import { Response, NextFunction } from 'express';
import { query, getClient } from '../database/db';
import { AppError } from '../middleware/errorHandler';
import { AuthRequest } from '../middleware/auth';
import { clearCachePattern } from '../config/redis';
import {
  validateCustomerData,
  validateGuarantorData,
  validateEmploymentData,
  checkDuplicateCustomer,
  findCustomerByNICOrMobile,
  checkCircularGuarantor,
  createDuplicateErrorResponse,
  normalizeNIC,
  normalizeMobile,
  GuarantorData
} from '../utils/customerValidation';

/**
 * Create a new customer with enhanced validation and guarantor handling
 * 
 * Features:
 * - System-generated unique customer_number
 * - Duplicate prevention (NIC and mobile)
 * - Guarantor reuse or auto-creation
 * - Circular relationship prevention
 * - Transaction-based consistency
 */
export async function createCustomer(req: AuthRequest, res: Response, next: NextFunction) {
  const client = await getClient();
  
  try {
    await client.query('BEGIN');

    const {
      name, nic, dob, gender, mobile_primary, mobile_secondary, email,
      permanent_address, current_address, notes,
      employment, guarantors
    } = req.body;

    // Validate and normalize customer data
    const { validatedData, normalizedNIC, normalizedMobile } = validateCustomerData({
      name,
      nic,
      dob,
      gender,
      mobile_primary,
      mobile_secondary,
      email,
      permanent_address
    });

    // Check for duplicate customer (NIC or mobile)
    const duplicateCheck = await checkDuplicateCustomer(
      client,
      normalizedNIC,
      normalizedMobile
    );

    if (duplicateCheck.isDuplicate) {
      throw createDuplicateErrorResponse(
        duplicateCheck.duplicateField!,
        duplicateCheck.existingCustomer!
      );
    }

    // Create customer (customer_number will be auto-generated by trigger)
    const customerResult = await client.query(
      `INSERT INTO customers (
        name, nic, dob, gender, mobile_primary, mobile_secondary, email,
        permanent_address, current_address, notes, created_by
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *`,
      [
        validatedData.name,
        validatedData.nic,
        new Date(validatedData.dob!).toISOString().slice(0, 10),
        validatedData.gender,
        validatedData.mobile_primary,
        validatedData.mobile_secondary || null,
        validatedData.email || null,
        validatedData.permanent_address,
        current_address || null,
        notes || null,
        req.user!.id
      ]
    );

    const customer = customerResult.rows[0];

    // Add employment details if provided
    if (employment) {
      validateEmploymentData(employment);
      
      const empStartDate = employment.start_date && employment.start_date.toString().trim() !== '' 
        ? new Date(employment.start_date).toISOString().slice(0, 10) 
        : null;

      await client.query(
        `INSERT INTO customer_employment (
          customer_id, employment_type, company_name, job_title,
          work_address, monthly_salary, payment_type, start_date
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
        [
          customer.id,
          employment.employment_type,
          employment.company_name,
          employment.job_title || null,
          employment.work_address || null,
          employment.monthly_salary,
          employment.payment_type || null,
          empStartDate
        ]
      );
    }

    // Handle guarantors (can be single object or array)
    const guarantorList = guarantors 
      ? (Array.isArray(guarantors) ? guarantors : [guarantors])
      : [];
    
    const addedGuarantors = [];

    for (const guarantorData of guarantorList) {
      // Validate guarantor data
      validateGuarantorData(guarantorData as GuarantorData);
      
      const guarantorNIC = normalizeNIC(guarantorData.nic);
      const guarantorMobile = normalizeMobile(guarantorData.mobile);
      
      // Check if guarantor already exists as a customer
      const existingGuarantor = await findCustomerByNICOrMobile(
        client,
        guarantorNIC,
        guarantorMobile
      );
      
      let guarantorId: number;
      
      if (existingGuarantor.found) {
        // Reuse existing customer as guarantor
        guarantorId = existingGuarantor.customer!.id;
        
        addedGuarantors.push({
          id: guarantorId,
          customer_number: existingGuarantor.customer!.customer_number,
          name: existingGuarantor.customer!.name,
          nic: existingGuarantor.customer!.nic,
          mobile: existingGuarantor.customer!.mobile_primary,
          reused: true
        });
      } else {
        // Create new customer for the guarantor
        const guarantorDOB = guarantorData.dob 
          ? new Date(guarantorData.dob).toISOString().slice(0, 10)
          : new Date(new Date().setFullYear(new Date().getFullYear() - 30)).toISOString().slice(0, 10); // Default 30 years old
        
        const newGuarantorResult = await client.query(
          `INSERT INTO customers (
            name, nic, dob, gender, mobile_primary, email,
            permanent_address, is_guarantor, created_by, notes
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, TRUE, $8, $9)
          RETURNING *`,
          [
            guarantorData.name,
            guarantorNIC,
            guarantorDOB,
            guarantorData.gender || 'other',
            guarantorMobile,
            guarantorData.email || null,
            guarantorData.address,
            req.user!.id,
            'Auto-created as guarantor'
          ]
        );
        
        guarantorId = newGuarantorResult.rows[0].id;
        
        addedGuarantors.push({
          id: guarantorId,
          customer_number: newGuarantorResult.rows[0].customer_number,
          name: newGuarantorResult.rows[0].name,
          nic: newGuarantorResult.rows[0].nic,
          mobile: newGuarantorResult.rows[0].mobile_primary,
          reused: false
        });
      }
      
      // Check for circular relationship
      const circularCheck = await checkCircularGuarantor(client, customer.id, guarantorId);
      
      if (circularCheck.isCircular) {
        throw new AppError(
          `Cannot add guarantor: Circular relationship detected. ` +
          `This would create a dependency loop in the guarantor chain.`,
          400
        );
      }
      
      // Create the guarantor relationship
      await client.query(
        `INSERT INTO customer_relationships (
          customer_id, guarantor_id, relationship_type, 
          relationship_description, workplace, created_by
        ) VALUES ($1, $2, $3, $4, $5, $6)`,
        [
          customer.id,
          guarantorId,
          'guarantor',
          guarantorData.relationship || null,
          guarantorData.workplace || null,
          req.user!.id
        ]
      );
    }

    // Audit log
    await client.query(
      'INSERT INTO audit_logs (user_id, action, entity_type, entity_id, new_values) VALUES ($1, $2, $3, $4, $5)',
      [
        req.user!.id,
        'CREATE_CUSTOMER',
        'customer',
        customer.id,
        JSON.stringify({
          customer,
          guarantorsAdded: addedGuarantors.length
        })
      ]
    );

    await client.query('COMMIT');
    await clearCachePattern('customers:*');

    res.status(201).json({
      success: true,
      message: 'Customer created successfully',
      data: {
        customer: {
          id: customer.id,
          customer_number: customer.customer_number,
          name: customer.name,
          nic: customer.nic,
          mobile_primary: customer.mobile_primary,
          email: customer.email
        },
        guarantors: addedGuarantors
      }
    });
  } catch (error) {
    await client.query('ROLLBACK');
    
    // Map PostgreSQL errors to user-friendly messages
    const errAny: any = error;
    
    if (errAny && errAny.code === '23505') {
      // unique_violation
      if (errAny.constraint === 'idx_customers_nic_unique') {
        return next(new AppError(
          'A customer with this NIC already exists. Please check the NIC and try again.',
          409
        ));
      } else if (errAny.constraint === 'idx_customers_mobile_primary_unique') {
        return next(new AppError(
          'A customer with this mobile number already exists. Please check the mobile number and try again.',
          409
        ));
      } else {
        return next(new AppError('Duplicate entry detected. Please check your data.', 409));
      }
    }
    
    if (errAny && errAny.code === '23514') {
      // check_constraint_violation
      return next(new AppError(
        errAny.message || 'Data validation failed. Please check your input.',
        400
      ));
    }
    
    next(error);
  } finally {
    client.release();
  }
}

export async function getCustomers(req: AuthRequest, res: Response, next: NextFunction) {
  try {
    const { page = 1, limit = 20, search, risk_flag, sort = 'created_at', order = 'DESC' } = req.query;
    
    const offset = (Number(page) - 1) * Number(limit);
    let whereClause = 'WHERE 1=1';
    const params: any[] = [];
    let paramIndex = 1;

    if (search) {
      whereClause += ` AND (name ILIKE $${paramIndex} OR nic ILIKE $${paramIndex} OR mobile_primary ILIKE $${paramIndex})`;
      params.push(`%${search}%`);
      paramIndex++;
    }

    if (risk_flag) {
      whereClause += ` AND risk_flag = $${paramIndex}`;
      params.push(risk_flag);
      paramIndex++;
    }

    const countResult = await query(
      `SELECT COUNT(*) FROM customers ${whereClause}`,
      params
    );

    const result = await query(
      `SELECT c.*, 
        ce.employment_type, ce.company_name, ce.monthly_salary,
        COUNT(DISTINCT s.id) as total_sales,
        COALESCE(SUM(i.remaining_balance), 0) as outstanding_balance
      FROM customers c
      LEFT JOIN customer_employment ce ON c.id = ce.customer_id
      LEFT JOIN sales s ON c.id = s.customer_id
      LEFT JOIN invoices i ON c.id = i.customer_id AND i.status != 'paid'
      ${whereClause}
      GROUP BY c.id, ce.employment_type, ce.company_name, ce.monthly_salary
      ORDER BY ${sort} ${order}
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`,
      [...params, Number(limit), offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total: parseInt(countResult.rows[0].count),
        pages: Math.ceil(countResult.rows[0].count / Number(limit)),
      },
    });
  } catch (error) {
    next(error);
  }
}

export async function getCustomerById(req: AuthRequest, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;

    const result = await query(
      'SELECT * FROM customers WHERE id = $1',
      [id]
    );

    if (result.rows.length === 0) {
      throw new AppError('Customer not found', 404);
    }

    res.json({
      success: true,
      data: result.rows[0],
    });
  } catch (error) {
    next(error);
  }
}

export async function getCustomerWithDetails(req: AuthRequest, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;

    const customerResult = await query('SELECT * FROM customers WHERE id = $1', [id]);
    if (customerResult.rows.length === 0) {
      throw new AppError('Customer not found', 404);
    }

    const employmentResult = await query(
      'SELECT * FROM customer_employment WHERE customer_id = $1',
      [id]
    );

    const guarantorResult = await query(
      'SELECT * FROM guarantors WHERE customer_id = $1',
      [id]
    );

    const documentsResult = await query(
      'SELECT id, document_type, file_name, file_size, uploaded_at FROM documents WHERE customer_id = $1',
      [id]
    );

    const salesResult = await query(
      'SELECT * FROM sales WHERE customer_id = $1 ORDER BY created_at DESC',
      [id]
    );

    const invoicesResult = await query(
      'SELECT * FROM invoices WHERE customer_id = $1 ORDER BY created_at DESC',
      [id]
    );

    const paymentsResult = await query(
      'SELECT * FROM payments WHERE customer_id = $1 ORDER BY payment_date DESC LIMIT 10',
      [id]
    );

    // Flatten the response - merge all data into the customer object
    const customerData = {
      ...customerResult.rows[0],
      employment: employmentResult.rows[0] || null,
      guarantors: guarantorResult.rows,
      documents: documentsResult.rows,
      sales: salesResult.rows,
      invoices: invoicesResult.rows,
      recentPayments: paymentsResult.rows,
    };

    res.json({
      success: true,
      data: customerData,
    });
  } catch (error) {
    next(error);
  }
}

export async function updateCustomer(req: AuthRequest, res: Response, next: NextFunction) {
  const client = await getClient();
  
  try {
    await client.query('BEGIN');

    const { id } = req.params;
    const updateData = req.body;

    // Get old values for audit
    const oldResult = await client.query('SELECT * FROM customers WHERE id = $1', [id]);
    if (oldResult.rows.length === 0) {
      throw new AppError('Customer not found', 404);
    }

    const fields = [];
    const values = [];
    let paramIndex = 1;

    const allowedFields = [
      'name', 'nic', 'dob', 'gender', 'mobile_primary', 'mobile_secondary',
      'email', 'permanent_address', 'current_address', 'notes'
    ];

    for (const field of allowedFields) {
      if (updateData[field] !== undefined) {
        fields.push(`${field} = $${paramIndex}`);
        values.push(updateData[field]);
        paramIndex++;
      }
    }

    if (fields.length === 0) {
      throw new AppError('No fields to update', 400);
    }

    values.push(id);
    const result = await client.query(
      `UPDATE customers SET ${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP 
       WHERE id = $${paramIndex} RETURNING *`,
      values
    );

    // Update employment if provided
    if (updateData.employment) {
      await client.query(
        `INSERT INTO customer_employment (
          customer_id, employment_type, company_name, job_title,
          work_address, monthly_salary, payment_type, start_date
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        ON CONFLICT (customer_id) DO UPDATE SET
          employment_type = EXCLUDED.employment_type,
          company_name = EXCLUDED.company_name,
          job_title = EXCLUDED.job_title,
          work_address = EXCLUDED.work_address,
          monthly_salary = EXCLUDED.monthly_salary,
          payment_type = EXCLUDED.payment_type,
          start_date = EXCLUDED.start_date`,
        [id, updateData.employment.employment_type, updateData.employment.company_name,
          updateData.employment.job_title, updateData.employment.work_address,
          updateData.employment.monthly_salary, updateData.employment.payment_type,
          updateData.employment.start_date]
      );
    }

    // Audit log
    await client.query(
      'INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values) VALUES ($1, $2, $3, $4, $5, $6)',
      [req.user!.id, 'UPDATE_CUSTOMER', 'customer', id, JSON.stringify(oldResult.rows[0]), JSON.stringify(result.rows[0])]
    );

    await client.query('COMMIT');
    await clearCachePattern('customers:*');

    res.json({
      success: true,
      data: result.rows[0],
    });
  } catch (error) {
    await client.query('ROLLBACK');
    next(error);
  } finally {
    client.release();
  }
}

export async function updateCustomerFlag(req: AuthRequest, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    const { risk_flag } = req.body;

    if (!['green', 'yellow', 'red'].includes(risk_flag)) {
      throw new AppError('Invalid risk flag', 400);
    }

    const result = await query(
      'UPDATE customers SET risk_flag = $1, flag_override = TRUE WHERE id = $2 RETURNING *',
      [risk_flag, id]
    );

    if (result.rows.length === 0) {
      throw new AppError('Customer not found', 404);
    }

    // Audit log
    await query(
      'INSERT INTO audit_logs (user_id, action, entity_type, entity_id, new_values) VALUES ($1, $2, $3, $4, $5)',
      [req.user!.id, 'UPDATE_CUSTOMER_FLAG', 'customer', id, JSON.stringify({ risk_flag })]
    );

    await clearCachePattern('customers:*');

    res.json({
      success: true,
      data: result.rows[0],
    });
  } catch (error) {
    next(error);
  }
}

export async function deleteCustomer(req: AuthRequest, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;

    const result = await query('DELETE FROM customers WHERE id = $1 RETURNING *', [id]);

    if (result.rows.length === 0) {
      throw new AppError('Customer not found', 404);
    }

    // Audit log
    await query(
      'INSERT INTO audit_logs (user_id, action, entity_type, entity_id) VALUES ($1, $2, $3, $4)',
      [req.user!.id, 'DELETE_CUSTOMER', 'customer', id]
    );

    await clearCachePattern('customers:*');

    res.json({
      success: true,
      message: 'Customer deleted successfully',
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Add a guarantor to an existing customer
 * Handles reuse of existing customers or creation of new ones
 */
export async function addGuarantor(req: AuthRequest, res: Response, next: NextFunction) {
  const client = await getClient();
  
  try {
    await client.query('BEGIN');
    
    const { id } = req.params;
    const guarantorData = req.body;
    
    // Verify customer exists
    const customerResult = await client.query(
      'SELECT id, customer_number, name FROM customers WHERE id = $1',
      [id]
    );
    
    if (customerResult.rows.length === 0) {
      throw new AppError('Customer not found', 404);
    }
    
    const customer = customerResult.rows[0];
    
    // Validate guarantor data
    validateGuarantorData(guarantorData as GuarantorData);
    
    const guarantorNIC = normalizeNIC(guarantorData.nic);
    const guarantorMobile = normalizeMobile(guarantorData.mobile);
    
    // Check if guarantor already exists as a customer
    const existingGuarantor = await findCustomerByNICOrMobile(
      client,
      guarantorNIC,
      guarantorMobile
    );
    
    let guarantorId: number;
    let guarantorInfo: any;
    let wasReused = false;
    
    if (existingGuarantor.found) {
      // Reuse existing customer as guarantor
      guarantorId = existingGuarantor.customer!.id;
      guarantorInfo = existingGuarantor.customer;
      wasReused = true;
      
      // Check if this relationship already exists
      const existingRelationship = await client.query(
        `SELECT id FROM customer_relationships 
         WHERE customer_id = $1 AND guarantor_id = $2`,
        [id, guarantorId]
      );
      
      if (existingRelationship.rows.length > 0) {
        throw new AppError(
          `This customer is already a guarantor for ${customer.name}`,
          409
        );
      }
    } else {
      // Create new customer for the guarantor
      const guarantorDOB = guarantorData.dob 
        ? new Date(guarantorData.dob).toISOString().slice(0, 10)
        : new Date(new Date().setFullYear(new Date().getFullYear() - 30)).toISOString().slice(0, 10);
      
      const newGuarantorResult = await client.query(
        `INSERT INTO customers (
          name, nic, dob, gender, mobile_primary, email,
          permanent_address, is_guarantor, created_by, notes
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, TRUE, $8, $9)
        RETURNING *`,
        [
          guarantorData.name,
          guarantorNIC,
          guarantorDOB,
          guarantorData.gender || 'other',
          guarantorMobile,
          guarantorData.email || null,
          guarantorData.address,
          req.user!.id,
          'Auto-created as guarantor'
        ]
      );
      
      guarantorId = newGuarantorResult.rows[0].id;
      guarantorInfo = newGuarantorResult.rows[0];
    }
    
    // Check for circular relationship
    const circularCheck = await checkCircularGuarantor(client, parseInt(id), guarantorId);
    
    if (circularCheck.isCircular) {
      throw new AppError(
        `Cannot add guarantor: Circular relationship detected. ` +
        `This would create a dependency loop in the guarantor chain.`,
        400
      );
    }
    
    // Create the guarantor relationship
    await client.query(
      `INSERT INTO customer_relationships (
        customer_id, guarantor_id, relationship_type, 
        relationship_description, workplace, created_by
      ) VALUES ($1, $2, $3, $4, $5, $6)`,
      [
        id,
        guarantorId,
        'guarantor',
        guarantorData.relationship || null,
        guarantorData.workplace || null,
        req.user!.id
      ]
    );
    
    // Audit log
    await client.query(
      'INSERT INTO audit_logs (user_id, action, entity_type, entity_id, new_values) VALUES ($1, $2, $3, $4, $5)',
      [
        req.user!.id,
        'ADD_GUARANTOR',
        'customer',
        id,
        JSON.stringify({ guarantorId, wasReused })
      ]
    );
    
    await client.query('COMMIT');
    await clearCachePattern('customers:*');
    
    res.status(201).json({
      success: true,
      message: `Guarantor ${wasReused ? 'linked' : 'created and linked'} successfully`,
      data: {
        guarantor: {
          id: guarantorId,
          customer_number: guarantorInfo.customer_number,
          name: guarantorInfo.name,
          nic: guarantorInfo.nic,
          mobile: guarantorInfo.mobile_primary,
          reused: wasReused
        }
      }
    });
  } catch (error) {
    await client.query('ROLLBACK');
    
    const errAny: any = error;
    if (errAny && errAny.code === '23505') {
      return next(new AppError('This guarantor relationship already exists', 409));
    }
    
    next(error);
  } finally {
    client.release();
  }
}

/**
 * Get all guarantors for a customer
 */
export async function getCustomerGuarantors(req: AuthRequest, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    
    const result = await query(
      `SELECT 
        g.id as guarantor_id,
        g.customer_number as guarantor_number,
        g.name as guarantor_name,
        g.nic as guarantor_nic,
        g.mobile_primary as guarantor_mobile,
        g.email as guarantor_email,
        g.permanent_address as guarantor_address,
        cr.relationship_type,
        cr.relationship_description,
        cr.workplace,
        cr.created_at as linked_at
      FROM customer_relationships cr
      INNER JOIN customers g ON cr.guarantor_id = g.id
      WHERE cr.customer_id = $1
      ORDER BY cr.created_at DESC`,
      [id]
    );
    
    res.json({
      success: true,
      data: result.rows
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Get all customers for whom this customer is a guarantor
 */
export async function getCustomersForGuarantor(req: AuthRequest, res: Response, next: NextFunction) {
  try {
    const { id } = req.params;
    
    const result = await query(
      `SELECT 
        c.id as customer_id,
        c.customer_number,
        c.name as customer_name,
        c.nic as customer_nic,
        c.mobile_primary as customer_mobile,
        c.risk_flag,
        cr.relationship_type,
        cr.relationship_description,
        cr.created_at as linked_at,
        COALESCE(SUM(i.remaining_balance), 0) as outstanding_balance
      FROM customer_relationships cr
      INNER JOIN customers c ON cr.customer_id = c.id
      LEFT JOIN invoices i ON c.id = i.customer_id AND i.status != 'paid'
      WHERE cr.guarantor_id = $1
      GROUP BY c.id, c.customer_number, c.name, c.nic, c.mobile_primary, 
               c.risk_flag, cr.relationship_type, cr.relationship_description, cr.created_at
      ORDER BY cr.created_at DESC`,
      [id]
    );
    
    res.json({
      success: true,
      data: result.rows,
      message: result.rows.length > 0 
        ? `This customer is a guarantor for ${result.rows.length} customer(s)`
        : 'This customer is not a guarantor for anyone'
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Remove a guarantor relationship
 */
export async function removeGuarantor(req: AuthRequest, res: Response, next: NextFunction) {
  const client = await getClient();
  
  try {
    await client.query('BEGIN');
    
    const { id, guarantorId } = req.params;
    
    const result = await client.query(
      `DELETE FROM customer_relationships 
       WHERE customer_id = $1 AND guarantor_id = $2
       RETURNING *`,
      [id, guarantorId]
    );
    
    if (result.rows.length === 0) {
      throw new AppError('Guarantor relationship not found', 404);
    }
    
    // Audit log
    await client.query(
      'INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values) VALUES ($1, $2, $3, $4, $5)',
      [req.user!.id, 'REMOVE_GUARANTOR', 'customer', id, JSON.stringify({ guarantorId })]
    );
    
    await client.query('COMMIT');
    await clearCachePattern('customers:*');
    
    res.json({
      success: true,
      message: 'Guarantor relationship removed successfully'
    });
  } catch (error) {
    await client.query('ROLLBACK');
    next(error);
  } finally {
    client.release();
  }
}

/**
 * Validate customer data for potential duplicates (for frontend validation)
 */
export async function validateCustomerUniqueness(req: AuthRequest, res: Response, next: NextFunction) {
  try {
    const { nic, mobile } = req.body;
    
    if (!nic && !mobile) {
      throw new AppError('NIC or mobile number is required for validation', 400);
    }
    
    const client = await getClient();
    
    const nicNormalized = nic ? normalizeNIC(nic) : null;
    const mobileNormalized = mobile ? normalizeMobile(mobile) : null;
    
    const duplicateCheck = await checkDuplicateCustomer(
      client,
      nicNormalized || '',
      mobileNormalized || ''
    );
    
    client.release();
    
    if (duplicateCheck.isDuplicate) {
      res.json({
        success: true,
        isUnique: false,
        duplicateField: duplicateCheck.duplicateField,
        existingCustomer: {
          id: duplicateCheck.existingCustomer!.id,
          customer_number: duplicateCheck.existingCustomer!.customer_number,
          name: duplicateCheck.existingCustomer!.name,
          nic: duplicateCheck.existingCustomer!.nic,
          mobile: duplicateCheck.existingCustomer!.mobile_primary
        }
      });
    } else {
      res.json({
        success: true,
        isUnique: true,
        message: 'Customer data is unique'
      });
    }
  } catch (error) {
    next(error);
  }
}

